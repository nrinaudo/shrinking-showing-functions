 <!DOCTYPE html>
<html>
    <head>
        <title>Shrinking and showing functions (in Scala)</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
        <link rel="stylesheet" type="text/css" href="css/style.css"/>
    </head>
    <body>
        <textarea id="source">
class: center, middle

# Shrinking and showing functions (in Scala)

Nicolas Rinaudo • [@NicolasRinaudo] • [Besedo]

---




```scala
val propReverseAppend = forAllNoShrink { (
    xs: List[Int],
    ys: List[Int]
  ) =>
    xs.reverse ++ ys.reverse == (xs ++ ys).reverse
}
```
--

```scala
validate(propReverseAppend)
// ✖ Failed with:
//  - ARG_0: List(2147483647, -416991762, 1919426110, 214748364…
//  - ARG_1: List(1983671757, 1143650104, -756315050, 181756746…
```

---

```scala
val propReverseAppend = forAll { (
    xs: List[Int],
    ys: List[Int]
  ) =>
    xs.reverse ++ ys.reverse == (xs ++ ys).reverse
}
```
--

```scala
validate(propReverseAppend)
// ✖ Failed with:
//  - ARG_0: List(0)
//  - ARG_1: List(1)
```

---

```scala
val propMapFilter = forAll { (
    is: List[Int],
    f : Int => Int,
    p : Int => Boolean
  ) =>
    is.filter(p).map(f) == is.map(f).filter(p)
}
```

--

```scala
validate(propMapFilter)
// ✖ Failed with:
//  - ARG_0: List(1)
//  - ARG_1: <function>
//  - ARG_2: <function>
```

---

class: center, middle

# `Unit => C`

---

```scala
val propUnit = forAll { (f: Unit => Int) =>
  f() == 0
}
```

--

```scala
validate(propUnit)
// ✖ Failed with:
//  - ARG_0: <function>
```

---

```scala
case class UnitFun[C](value: C) extends (Unit => C) {

  override def apply(u: Unit) = value

  override def toString = s"{() => $value}"
}
```

---

```scala
implicit def arbUnitFun[C: Arbitrary] = Arbitrary[Unit => C](
  arbitrary[C].map(UnitFun.apply)
)
```

---

```scala
val propUnit = forAll { (f: Unit => Int) =>
  f() == 0
}
```

--

```scala
validate(propUnit)
// ✖ Failed with:
//  - ARG_0: {() => 581163233}
```

---

```scala
implicit def shrinkUnit[C: Shrink] = Shrink[Unit => C] {

    case UnitFun(c) => shrink(c).map(UnitFun.apply)

    case _          => Stream.empty
}
```

---

```scala
val propUnit = forAll { (f: Unit => Int) =>
  f() == 0
}
```

--

```scala
validate(propUnit)
// ✖ Failed with:
//  - ARG_0: {() => 1}
```

---

## Key takeaways

When the domain is small enough, it's easy:
- introduce a dedicated type with custom toString and shrink
- override the default `Arbitrary` function instance for that type.


---

class: center, middle

# `Boolean => C`

---

```scala
val propBool = forAll { (f: Boolean => Int) =>
  f(true) == f(false)
}
```

--

```scala
validate(propBool)
// ✖ Failed with:
//  - ARG_0: <function>
```

---

```scala
case class BoolFun[C](f: Boolean => C) extends (Boolean => C) {
  override def apply(b: Boolean) = f(b)
  override def toString =
    s"{true => ${f(true)}, false => ${f(false)}}"
}
```

---

```scala
def genBoolean[C: Arbitrary]: Gen[Boolean => C] =
  Gen.function1[Boolean, C](arbitrary[C]).
    map(BoolFun.apply)

implicit def arbBoolean[C: Arbitrary]: Arbitrary[Boolean => C] =
  Arbitrary(genBoolean[C])
```

---

```scala
val propBool = forAll { (f: Boolean => Int) =>
  f(true) == f(false)
}
```

--

```scala
validate(propBool)
// ✖ Failed with:
//  - ARG_0: {true => 2147483647, false => 1862882517}
```

---

```scala
def booleanFunction[C](onTrue: => C, onFalse: => C): Boolean => C =  {
  case true  => onTrue
  case false => onFalse
}
```

```scala
implicit def shrinkBoolean[C: Shrink]: Shrink[Boolean => C] =
  Shrink {
    case BoolFun(f) =>
      shrink(f(true)).map(c => BoolFun(booleanFunction(c, f(false)))) #:::
      shrink(f(false)).map(c => BoolFun(booleanFunction(f(true), c)))

    case _ =>
      Stream.empty
  }
```

---

```scala
val propBool = forAll { (f: Boolean => Int) =>
  f(true) == f(false)
}
```

--

```scala
validate(propBool)
// ✖ Failed with:
//  - ARG_0: {true => 0, false => 1}
```

---

## Key takeaways

Working with booleans is not very different than with units.

Maybe we can factor out the common aspects?

---

class: center, middle

# `A =>> C`





---

Not taking a Shrink[C] here because I'm listing the things we need from the initial implems:
- `toString` (which we refactor to `table`)
- a shrinking mechanism

```scala
trait =>>[A, C] extends (A => C) {
  def table: List[(A, C)]
  def shrink(shrinkC: C => Stream[C]): Stream[A =>> C]

  override def toString = table.map { case (in, out) => s"$in => $out" }.mkString("{", ", ", "}")
}
```

---

```scala
implicit def shrinkFunction[A, C: Shrink] = Shrink[A => C] {

  case f: (A =>> C) => f.shrink(shrink[C])

  case _            => Stream.empty
}

```

---

Let's define a creation helper so that it's slightly less painful in the future...

---

```scala
def fun[A, C](
  eval    : A => C,
  values  : => List[(A, C)],
  shrinker: (C => Stream[C]) => Stream[A =>> C]
) = new (A =>> C) {

  override def apply(a: A) = eval(a)

  override def table = values

  override def shrink(shrinkC: C => Stream[C]) = shrinker(shrinkC)
}
```

---

```scala
def unit[C](value: C): (Unit =>> C) = fun(
  eval     = _ => value,

  values   = List(() -> value),

  shrinker = shrinkC => shrinkC(value).map(unit)
)
```

---

```scala
implicit def arbFun[A: Cogen, C: Arbitrary] = Arbitrary[A => C] {
  Gen.function1[A, C](arbitrary[C]).map(???)
}
```

Can we abstract over the notion of, given an `A => C`, going into an `A =>> C`?

---

```scala
trait Argument[A] {
  def build[C](f: A => C): A =>> C
}

object Argument {
  def apply[A](implicit arg: Argument[A]): Argument[A] = arg
}
```

---

```scala
implicit def arbFun[A: Argument: Cogen, C: Arbitrary] =
  Arbitrary[A => C] {
    Gen.function1[A, C](arbitrary[C]).
      map(Argument[A].build)
  }
```

---

```scala
implicit def argUnit = new Argument[Unit] {
  override def build[C](f: Unit => C) = unit(f())
}
```

---

```scala
val propUnit = forAll { (f: Unit => Int) =>
  f() == 0
}
```

--

```scala
validate(propUnit)
// ✖ Failed with:
//  - ARG_0: {() => 1}
```

---

## Placeholder

```scala
def bool[C](f: Boolean => C): (Boolean =>> C) = {
  def copy(onTrue: C = f(true), onFalse: C = f(false)) = bool {
    case true  => onTrue
    case false => onFalse
  }

  fun(
    eval     = f,

    values   = List(true -> f(true), false -> f(false)),

    shrinker = shrinkC =>
      shrinkC(f(true)).map(c => copy(onTrue = c)) #:::
      shrinkC(f(false)).map(c => copy(onFalse = c))
  )
}
```

---

```scala
implicit def argBool = new Argument[Boolean] {
  override def build[C](f: Boolean => C) = bool(f)
}
```

---

```scala
val propBool = forAll { (f: Boolean => Int) =>
  f(true) == f(false)
}
```

--

```scala
validate(propBool)
// ✖ Failed with:
//  - ARG_0: {true => 0, false => 1}
```

---

```scala
sealed trait Answer

object Answer {
  case object Yes extends Answer
  case object No extends Answer
}
```

---

## Placeholder

```scala
def imap[A, B, C](
  to  : A => B,
  from: B => A,
  f   : B =>> C
): (A =>> C) = fun(

    eval     = to andThen f,

    values   = f.table.map {
      case (b, c) => (from(b),  c)
    },

    shrinker = shrinkC => f.
      shrink(shrinkC).
      map { b2c => imap(to, from, b2c) }
  )
```

---

```scala
implicit val argAnswer = new Argument[Answer] {
  val to: Answer => Boolean = {
    case Answer.Yes => true
    case Answer.No  => false
  }

  val from: Boolean => Answer = {
    case true => Answer.Yes
    case false => Answer.No
  }

  override def build[C](f: Answer => C) =
    imap(to, from, bool(from andThen f))
}
```

---

```scala
val propAnswer = forAll { (f: Answer => Int) =>
  f(Answer.Yes) == f(Answer.No)
}
```

--

```scala
validate(propAnswer)
// ✖ Failed with:
//  - ARG_0: {Yes => 0, No => 1}
```

---

```scala
def argMap[A, B: Argument](to: A => B, from: B => A) =
  new Argument[A] {
    override def build[C](f: A => C) =
      imap(to, from, Argument[B].build(from andThen f))
  }
```

---

```scala
implicit val argAnswer = {
  val to: Answer => Boolean = {
    case Answer.Yes => true
    case Answer.No  => false
  }

  val from: Boolean => Answer = {
    case true => Answer.Yes
    case false => Answer.No
  }

  argMap(to, from)
}
```

---

```scala
val propAnswer = forAll { (f: Answer => Int) =>
  f(Answer.Yes) == f(Answer.No)
}
```

--

```scala
validate(propAnswer)
// ✖ Failed with:
//  - ARG_0: {Yes => 0, No => 1}
```

---

At this point we've done something fairly nice: we've expressed an `Argument` for a given type in terms of a pre-existing instance for an equivalent type.

This is where we dig in our theorical knowledge to remember that types of equal arity were equivalent: it's always possible to have a mapping from one to the other and back.

What if we provided the basic building blocks?

---

Either, which is pretty simple: `Either[A, B] =>> C`.

A sum type is a discriminated union of values. So `Either[A, B]` is really `Left(a)` union `Right(b)`.

Similarly: `Either[A, B] =>> C` is really `Left[A] =>> C` union `Right[B] =>> C`


---

```scala
def left[A, B, C](f: A =>> C): (Either[A, B] =>> C) = fun(
  eval     = {
    case Left(a) => f(a)
    case Right(_) => ???
  },

  values   = f.table.map { case (a, c) => (Left(a), c) },

  shrinker = shrinkC => f.shrink(shrinkC).map(left)
)
```

---

We have a problem. `FunLeft` is suddenly not defined for all of its domain.

But... that's not a *problem*, it's a feature! We want to shrink our functions, right? This allows us to shrink their domains, removing entire swathes of possible values in one go.

This requires some refactoring though...

---




```scala
trait =>>[A, C] extends (A => Option[C]) {

  def table: List[(A, C)]

  def shrink(shrinkC: C => Stream[C]): Stream[A =>> C]

  override def toString = table.
    map { case (in, out) => s"$in => $out" }.
    mkString("{", ", ", "}")
}
```

---

```scala
def fun[A, C](
  eval    : A => Option[C],
  values  : => List[(A, C)],
  shrinker: (C => Stream[C]) => Stream[A =>> C]
) = new (A =>> C) {

  override def apply(a: A) = eval(a)

  override def table = values

  override def shrink(shrinkC: C => Stream[C]) = shrinker(shrinkC)
}
```

---

```scala
def unit[C](value: C): (Unit =>> C) = fun(
  eval     = _ => Some(value),
  values   = List(() -> value),
  shrinker = shrinkC => shrinkC(value).map(unit)
)
```

---

```scala
def void[A, C]: (A =>> C) = fun(
  eval     = _ => None,
  values   = List.empty,
  shrinker = _ => Stream.empty
)
```

---

```scala
def unit[C](value: C): (Unit =>> C) = fun(
  eval     = _ => Some(value),
  values   = List(() -> value),
  shrinker = shrinkC => void[Unit, C] #:: shrinkC(value).map(unit)
)
```

---

```scala
def imap[A, B, C](
  to  : A => B,
  from: B => A,
  f   : B =>> C
): (A =>> C) = fun(

  eval     = a => f(to(a)),

  values   = f.table.map { case (b, c) => from(b) -> c },

  shrinker = shrinkC => f.
    shrink(shrinkC).
    map { b2c => imap(to, from, b2c) }
)
```

---

Good opportunity to revisit the current infra we developed.

---

```scala
trait Argument[A] {
  def build[C](f: A => C): A =>> C
}

object Argument {
  def apply[A](implicit arg: Argument[A]): Argument[A] = arg
}
```

---


```scala
implicit def argUnit = new Argument[Unit] {
  override def build[C](f: Unit => C) = unit(f())
}

def argMap[A, B: Argument](to: A => B, from: B => A) = new Argument[A] {
  override def build[C](f: A => C) = imap(to, from, Argument[B].build(from andThen f))
}
```


---

```scala
implicit def arbFun[A: Argument: Cogen, C: Arbitrary] =
  Arbitrary[A => C] {
    Gen.function1[A, C](arbitrary[C]).
      map(Argument[A].build)
  }
//              map(Argument[A].build)
//                              ^
// On line 5: error: polymorphic expression cannot be instantiated to expected type;
//         found   : [C(in method build)](A => C(in method build)) => A =>> C(in method build)
//         required: (A => C(in method arbFun)) => (A => C(in method arbFun))
```

---

We can't do that, because `=>>` is partial, and we're working with total functions. We need some way of turning a `=>>` into a total function.

---

```scala
case class Fun[A, C](fun: A =>> C, undef: C) extends (A => C) {

  override def apply(a: A) = fun(a).getOrElse(undef)

  def shrink(shrinkC: C => Stream[C]): Stream[Fun[A, C]] =
    fun.shrink(shrinkC).map(f => copy(fun = f)) #:::
    shrinkC(undef).map(d => copy(undef = d))

  override def toString = {
    val raw = fun.table.map { case (a, c) => s"$a => $c" } ++
              List(s"_ => $undef")

    raw.mkString("{", ", ", "}")
  }
}
```

---

```scala
def genFun[A: Argument: Cogen, C: Arbitrary] =
  Gen.function1[A, C](arbitrary[C]).
    map(Argument[A].build)

implicit def arbFun[A: Argument: Cogen, C: Arbitrary] =
  Arbitrary[A => C](for {
    fun   <- genFun[A, C]
    undef <- arbitrary[C]
  } yield Fun(fun, undef))
```

---

```scala
implicit def shrinkFunction[A, C: Shrink] = Shrink[A => C] {

  case f: Fun[A, C] => f.shrink(shrink)

  case _            => Stream.empty
}
```

---

```scala
def left[A, B, C](f: A =>> C): (Either[A, B] =>> C) = fun(
  eval = {
    case Left(a)  => f(a)
    case Right(_) => None
  },
  values = f.table.map { case (a, c) => (Left(a), c) },
  shrinker = shrinkC => f.shrink(shrinkC).map(a2c => left(a2c))
)
```
---

```scala
def right[A, B, C](f: B =>> C): (Either[A, B] =>> C) = fun(
  eval = {
    case Left(_)  => None
    case Right(b) => f(b)
  },
  values = f.table.map { case (b, c) => (Right(b), c) },
  shrinker = shrinkC => f.shrink(shrinkC).map(b2c => right(b2c))
)
```

---

```scala
def union[A, C](f1: A =>> C, f2: A =>> C): (A =>> C) = fun(

  eval = a => f1(a).orElse(f2(a)),

  values = f1.table ++ f2.table,

  shrinker = shrinkC =>
    f1                                          #::
    f2                                          #::
    f1.shrink(shrinkC).map(f1 => union(f1, f2)) #:::
    f2.shrink(shrinkC).map(f2 => union(f1, f2))
)
```

---

```scala
implicit def argEither[A: Argument, B: Argument] = new Argument[Either[A, B]] {
  override def build[C](f: Either[A, B] => C) = union(
   left(Argument[A].build(a => f(Left(a)))),
   right(Argument[B].build(b => f(Right(b))))
  )
}
```

---

```scala
implicit val boolArg = {

  type Repr = Either[Unit, Unit]

  val to: Boolean => Repr = {
    case true => Left(())
    case false => Right(())
  }

  val from: Repr => Boolean = {
    case Left(()) => true
    case Right(()) => false
  }

  argMap(to, from)
}
```

---

```scala
val propBool = forAll { (f: Boolean => Int) =>
  f(true) == f(false)
}
```

--

```scala
validate(propBool)
// ✖ Failed with:
//  - ARG_0: {true => 0, _ => -1}
```

---

```scala
sealed trait Trilean

object Trilean {
  case object True extends Trilean
  case object False extends Trilean
  case object Unknown extends Trilean
}
```

---

## Placeholder

```scala
implicit val argTrilean = {

  type Repr = Either[Unit, Either[Unit, Unit]]

  val to: Trilean => Repr = {
    case Trilean.True    => Left(())
    case Trilean.False   => Right(Left(()))
    case Trilean.Unknown => Right(Right(()))
  }

  val from: Repr => Trilean = {
    case Left(())         => Trilean.True
    case Right(Left(()))  => Trilean.False
    case Right(Right(())) => Trilean.Unknown
  }

  argMap(to, from)
}
```

---

```scala
val propTrilean = forAll { (f: Trilean => Int) =>
  f(Trilean.True) == f(Trilean.False)
}
```

--

```scala
validate(propTrilean)
// ✖ Failed with:
//  - ARG_0: {True => 0, _ => -1}
```

---

## Placeholder

```scala
def couple[A, B, C](f: A =>> (B =>> C)): ((A, B) =>> C) = fun(

  eval = { case (a, b) =>
    for {
      b2c <- f(a)
      c   <- b2c(b)
    } yield c
  },

  values = for {
    (a, b2c) <- f.table
    (b, c)   <- b2c.table
  } yield (a, b) -> c,

  shrinker = shrinkC => f.
    shrink(b2c => b2c.shrink(shrinkC)).
    map(a2b2c => couple(a2b2c))
)
```

---

```scala
implicit def argTuple[A: Argument, B: Argument] = new Argument[(A, B)] {
  override def build[C](f: ((A, B)) => C) = couple(
    Argument[A].build(a => Argument[B].build(b => f((a, b))))
  )
}
```

---

```scala
case class BoolPair(b1: Boolean, b2: Boolean)

implicit val argBoolPair = {

  type Repr = (Boolean, Boolean)

  val to: BoolPair => Repr =
    pair => (pair.b1, pair.b2)

  val from: Repr => BoolPair = {
    case (b1, b2) => BoolPair(b1, b2)
  }

  argMap(to, from)
}
```

---

```scala
val propBoolPair = forAll { (f: BoolPair => Int) =>
  f(BoolPair(true, false)) == f(BoolPair(false, true))
}
```

--

```scala
validate(propBoolPair)
// ✖ Failed with:
//  - ARG_0: {BoolPair(true,false) => 0, _ => -1}
```

---

```scala
implicit def argOption[A: Argument] = {

  type Repr = Either[Unit, A]

  val to: Option[A] => Repr = {
    case Some(a) => Right(a)
    case None    => Left(())
  }

  val from: Repr => Option[A] = {
    case Right(a) => Some(a)
    case Left(_)  => None
  }

  argMap(to, from)
}
```

---

```scala
val propOption = forAll { (f: Option[Boolean] => Int) =>
  f(None) == f(Some(true))
}
```

--

```scala
validate(propOption)
// ✖ Failed with:
//  - ARG_0: {Some(true) => 0, _ => -1}
```

---

```scala
implicit def argList[A: Argument]: Argument[List[A]] = {

  type Repr = Option[(A, List[A])]

  val to: List[A] => Repr = {
    case head :: tail => Some((head, tail))
    case Nil          => None
  }

  val from: Repr => List[A] = {
    case Some((head, tail)) => head :: tail
    case None               => Nil
  }

  argMap(to, from)
}
```

---

.foreground[![Big badaboom](img/large-explosion.png)]

```scala
implicit def argList[A: Argument]: Argument[List[A]] = {

  type Repr = Option[(A, List[A])]

  val to: List[A] => Repr = {
    case head :: tail => Some((head, tail))
    case Nil          => None
  }

  val from: Repr => List[A] = {
    case Some((head, tail)) => head :: tail
    case None               => Nil
  }

  argMap(to, from)
}
```

---

```scala
def imap[A, B, C](
  to  : A => B,
  from: B => A,
  f   : => B =>> C
): (A =>> C) = fun(

  eval     = a => f(to(a)),

  values   = f.table.map { case (b, c) => from(b) -> c },

  shrinker = shrinkC => f.
    shrink(shrinkC).
    map { b2c => imap(to, from, b2c) }
)
```

---

```scala
def argMap[A, B](to: A => B, from: B => A)(implicit argB: => Argument[B]) = new Argument[A] {
  override def build[C](f: A => C) = imap(to, from, argB.build(from andThen f))
}
```

---

```scala
def left[A, B, C](f: => A =>> C): (Either[A, B] =>> C) = fun(
  eval = {
    case Left(a)  => f(a)
    case Right(_) => None
  },
  values = f.table.map { case (a, c) => (Left(a), c) },
  shrinker = shrinkC => f.shrink(shrinkC).map(a2c => left(a2c))
)
```
---

```scala
def right[A, B, C](f: => B =>> C): (Either[A, B] =>> C) = fun(
  eval = {
    case Left(_)  => None
    case Right(b) => f(b)
  },
  values = f.table.map { case (b, c) => (Right(b), c) },
  shrinker = shrinkC => f.shrink(shrinkC).map(b2c => right(b2c))
)
```

---

```scala
def union[A, C](f1: => A =>> C, f2: => A =>> C): (A =>> C) = fun(

  eval = a => f1(a).orElse(f2(a)),

  values = f1.table ++ f2.table,

  shrinker = shrinkC =>
    f1                                          #::
    f2                                          #::
    f1.shrink(shrinkC).map(f1 => union(f1, f2)) #:::
    f2.shrink(shrinkC).map(f2 => union(f1, f2))
)
```

---

```scala
implicit def argEither[A, B](implicit argA: => Argument[A], argB: => Argument[B]) = new Argument[Either[A, B]] {
  override def build[C](f: Either[A, B] => C) = union(
   left(argA.build(a => f(Left(a)))),
   right(argB.build(b => f(Right(b))))
  )
}
```

---

```scala
def couple[A, B, C](f: => A =>> (B =>> C)): ((A, B) =>> C) = fun(

  eval = { case (a, b) =>
    for {
      b2c <- f(a)
      c   <- b2c(b)
    } yield c
  },

  values = for {
    (a, b2c) <- f.table
    (b, c)   <- b2c.table
  } yield (a, b) -> c,

  shrinker = shrinkC => f.
    shrink(b2c => b2c.shrink(shrinkC)).
    map(a2b2c => couple(a2b2c))
)
```

---

```scala
implicit def argTuple[A, B](implicit argA: => Argument[A], argB: => Argument[B]) = new Argument[(A, B)] {
  override def build[C](f: ((A, B)) => C) = couple(
    argA.build(a => argB.build(b => f((a, b))))
  )
}
```

---

```scala
implicit def argList[A: Argument]: Argument[List[A]] = {

  type Repr = Option[(A, List[A])]

  val to: List[A] => Repr = {
    case head :: tail => Some((head, tail))
    case Nil          => None
  }

  val from: Repr => List[A] = {
    case Some((head, tail)) => head :: tail
    case None               => Nil
  }

  argMap(to, from)
}
```

---

```scala
val propList = forAll { (f: List[Boolean] => Int) =>
  f(List.empty) == f(List(true))
}
```

--

```scala
validate(propList)
// ✖ Failed with:
//  - ARG_0: {List(true) => 0, _ => -1}
```

---

## Placeholder

```scala
implicit def argInt: Argument[Int] = {

  type Repr = Either[(Boolean, Int), Boolean]

  def div2(i: Int): Int = math.floor(i / 2D).toInt

  val to: Int => Repr = {
    case 0  => Right(false)
    case -1 => Right(true)
    case i  => Left((i % 2 != 0, div2(i)))
  }

  val from: Repr => Int = {
    case Right(true)  => -1
    case Right(false) => 0
    case Left((b, i)) => 2 * i + (if(b) 1 else 0)
  }

  argMap(to, from)
}
```

---

```scala
val propInt = forAll { (f: Int => Int) =>
  f(1) == f(2)
}
```

--

```scala
validate(propInt)
// ✖ Failed with:
//  - ARG_0: {1 => 0, _ => -1}
```

---

```scala
implicit val argChar: Argument[Char] =
  argMap[Char, Int](_.toInt, _.toChar)
```

---

```scala
val propChar = forAll { (f: Char => Int) =>
  f('a') == f('b')
}
```

--

```scala
validate(propChar)
// ✖ Failed with:
//  - ARG_0: {a => 0, _ => -1}
```

---

```scala
implicit val argString: Argument[String] =
  argMap[String, List[Char]](_.toList, _.mkString)
```

---

```scala
val propString = forAll { (f: String => Int) =>
  f("Haskell") == f("Scala")
}
```

--

```scala
validate(propString)
// ✖ Failed with:
//  - ARG_0: {Scala => 0, _ => -1}
```

---

```scala
val propMapFilter = forAll { (
    is: List[Int],
    f : Int => Int,
    p : Int => Boolean
  ) =>
    is.filter(p).map(f) == is.map(f).filter(p)
}
```

--

```scala
validate(propMapFilter)
// ✖ Failed with:
//  - ARG_0: List(1)
//  - ARG_1: {_ => -3}
//  - ARG_2: {-3 => false, _ => true}
```

---

class: center, middle

# Questions?

Nicolas Rinaudo • [@NicolasRinaudo] • [Besedo]

[@NicolasRinaudo]:https://twitter.com/NicolasRinaudo
[Besedo]:https://twitter.com/besedo_official
    </textarea>
    <script src="js/remark.js" type="text/javascript">
    </script>
    <script type="text/javascript">
        var slideshow = remark.create({
          highlightStyle: 'github',
          highlightSpans: true,
          highlightLines: true
      });
    </script>
  </body>
</html>
